---
# **MySQL**
---

## 逻辑架构

大框架：server 层 + 存储引擎层

![](https://cdn.charlesnote.com/wiki/images/2022/02/22/233301381-296421dc08f89cbf71a4826c86cd31ed.png)

Server 层：包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），包括跨引擎功能：触发器，存储过程，视图
存储引擎层：负责数据存储，提取。MySQL 常用的存储引擎：MyISAM, InnoDB, Memory。目前默认是 `InnoDB`

### 连接器

```bash
mysql -h$ip -P$port -u$user -p
```

当执行以上指令后，由连接器负责与客户端连接，校验权限，维持管理连接。使用 `show processlist` 指令即可查看连接状况

```bash
mysql> show processlist;
+----+------+------------------+------+---------+------+----------+------------------+
| Id | User | Host             | db   | Command | Time | State    | Info             |
+----+------+------------------+------+---------+------+----------+------------------+
|  3 | root | 172.18.0.1:64402 | NULL | Query   |    0 | starting | show processlist |
|  4 | root | 172.18.0.1:64404 | NULL | Sleep   |    5 |          | NULL             |
+----+------+------------------+------+---------+------+----------+------------------+
```

!> 如果账号密码正确，连接器会从`权限表`获取该账号的权限，此后连接里对于权限的判断来自于此刻的数据，也就是管理员修改该用户的权限也不会影响已建立的连接，直到下次连接才会生效

?> 客户端如果太长时间没有空置，那么连接器会自动断开，由参数 `wait_timeout` 控制，默认是8小时

建立连接是一个资源消耗较大的操作，因此一般情况下，会通过建立数据库连接池的方法来保持长连接，但是长连接会有一定弊端，MySQL 的内存可能会暴涨，因为执行过程中临时使用的临时是管理在连接对象中的，一直到连接终结才释放。解决方法：
1. 定期释放长连接，重新连接
2. 通过执行 `mysql_reset_connection` 来重新初始化连接。（*需要在 MySQL 5.7 及其以上的版本支持*）

### 查询缓存

MySQL 在获取到 select 语句之后，会首先查询缓存数据。MySQL 对于之前查询语句和结果会以 k-v 的形式缓存在内存中。

> **但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。**

只有类似`静态变量`之类的表（例如系统配置信息表），才适合使用缓存。这类表的数据，基本不做更新操作。

MySQL 提供参数 query_cache_type 设置成 DEMAND，默认 SQL 语句不会使用缓存，如需使用缓存，可以显式指定

```sql
select SQL_CACHE * from T where id=1；
```

**在 MySQL 8.0 里面，查询缓存功能被彻底删除掉**，也就是在 MySQL 8.0 以上的版本，将无法再使用查询缓存的功能

### 分析器

没有命中缓存，开始真正执行 SQL 语句

执行流程（以 `select * from T where ID = 10;` 为例）：
1. “词法分析”：关键字识别，把 select 关键字识别为查询语句，把 T 识别为表名，把 ID 识别为列
2. “语法分析”：检查 SQL 语句是否满足 MySQL 语法。语法错误会提示 `You have an error in your SQL syntax`

### 优化器

经过分析器后，MySQL 可以知道 SQL 的目的，但是在真正执行前，还需要经过优化器的处理。优化器就是在表结构有多个索引的时候，决定使用哪个索引；或者在一个语句有多表联合（join）的时候，决定各个表的连接顺序。